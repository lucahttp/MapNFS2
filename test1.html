<!DOCTYPE html>
<html lang="en">

<head>
  <title>NFS SUC</title>
  <meta property="og:description" content="Use a custom style layer with three.js to add a 3D model to the map." />
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Fonts: Orbitron for numbers/tech, Rajdhani for body -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;600;700&display=swap"
    rel="stylesheet">

  <!-- MapLibre -->
  <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@5.14.0/dist/maplibre-gl.css' />
  <script src='https://unpkg.com/maplibre-gl@5.14.0/dist/maplibre-gl.js'></script>

  <!-- Turf.js for logic -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      font-family: 'Rajdhani', sans-serif;
      overflow: hidden;
      color: #00f3ff;
    }

    html,
    body,
    #map {
      height: 100%;
    }

    /* --- HUD AND UI STYLES --- */
    :root {
      --nfs-cyan: #00f3ff;
      --nfs-pink: #ff0055;
      --nfs-yellow: #ffe600;
      --nfs-dark: #0a0f1e;
      --nfs-dark-trans: rgba(10, 15, 30, 0.95);
      --hud-skew: -15deg;
    }

    .hud-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      box-sizing: border-box;
    }

    .hud-element {
      pointer-events: auto;
    }

    .top-bar {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 20px;
      box-sizing: border-box;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
    }

    .bottom-bar {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      padding: 20px;
      box-sizing: border-box;
      background: linear-gradient(0deg, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0) 100%);
    }

    /* Nav Hub */
    .nav-hub {
      position: relative;
      width: 350px;
      max-width: 100%;
    }

    .nav-input-container {
      position: relative;
      transform: skewX(var(--hud-skew));
      background: var(--nfs-dark-trans);
      border: 2px solid var(--nfs-cyan);
      padding: 5px;
      box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
    }

    .nav-label {
      position: absolute;
      top: -18px;
      left: 10px;
      font-size: 0.8rem;
      color: var(--nfs-yellow);
      font-weight: 700;
      text-shadow: 0 0 5px var(--nfs-yellow);
    }

    input.hud-input {
      width: 100%;
      background: transparent;
      border: none;
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      padding: 10px 20px;
      text-transform: uppercase;
      outline: none;
      transform: skewX(15deg);
    }

    input.hud-input::placeholder {
      color: rgba(0, 243, 255, 0.5);
    }

    .search-results {
      position: absolute;
      top: 110%;
      left: 0;
      width: 100%;
      background: var(--nfs-dark-trans);
      border: 1px solid var(--nfs-cyan);
      max-height: 250px;
      overflow-y: auto;
      display: none;
      transform: skewX(var(--hud-skew));
    }

    .result-item {
      padding: 12px 15px;
      border-bottom: 1px solid rgba(0, 243, 255, 0.2);
      color: #fff;
      cursor: pointer;
      transform: skewX(15deg);
      transition: background 0.2s;
      font-size: 1.1rem;
    }

    .result-item:hover {
      background: rgba(0, 243, 255, 0.2);
      color: var(--nfs-yellow);
    }

    /* Route Panel */
    .route-panel {
      position: absolute;
      top: 80px;
      left: 20px;
      width: 350px;
      max-width: 90%;
      background: var(--nfs-dark-trans);
      border: 2px solid var(--nfs-yellow);
      transform: skewX(var(--hud-skew));
      padding: 15px;
      display: none;
      box-shadow: 0 0 20px rgba(255, 230, 0, 0.2);
    }

    .route-row {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      transform: skewX(15deg);
    }

    .route-label {
      width: 50px;
      font-weight: bold;
      color: var(--nfs-cyan);
    }

    .route-input-box {
      flex: 1;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid var(--nfs-cyan);
      padding: 5px;
    }

    .route-input-box input {
      width: 100%;
      background: transparent;
      border: none;
      color: #fff;
      font-family: 'Rajdhani';
      font-size: 1rem;
      outline: none;
    }

    .btn-go {
      width: 100%;
      background: var(--nfs-pink);
      border: none;
      color: #fff;
      font-family: 'Orbitron';
      font-size: 1.2rem;
      padding: 10px;
      margin-top: 10px;
      cursor: pointer;
      text-transform: uppercase;
      font-weight: 900;
      transform: skewX(15deg);
      transition: 0.2s;
    }

    .btn-go:hover {
      background: #ff3377;
      box-shadow: 0 0 15px var(--nfs-pink);
    }

    /* Danger Widget */
    .danger-widget {
      display: none;
      background: rgba(255, 0, 85, 0.2);
      border: 2px solid var(--nfs-pink);
      padding: 10px 30px;
      transform: skewX(var(--hud-skew));
      box-shadow: 0 0 20px rgba(255, 0, 85, 0.4);
      animation: pulse-danger 1s infinite alternate;
    }

    .danger-text {
      color: var(--nfs-pink);
      font-family: 'Orbitron';
      font-weight: 900;
      font-size: 1.5rem;
      transform: skewX(15deg);
      text-transform: uppercase;
    }

    @keyframes pulse-danger {
      from {
        opacity: 0.6;
        box-shadow: 0 0 10px var(--nfs-pink);
      }

      to {
        opacity: 1;
        box-shadow: 0 0 30px var(--nfs-pink);
      }
    }

    /* History & Stats */
    .history-panel {
      background: var(--nfs-dark-trans);
      border-left: 4px solid var(--nfs-yellow);
      padding: 15px;
      max-width: 250px;
      transform: skewX(var(--hud-skew));
      margin-bottom: 10px;
    }

    .history-title {
      color: var(--nfs-yellow);
      font-family: 'Orbitron';
      font-size: 1rem;
      margin-bottom: 10px;
      transform: skewX(15deg);
    }

    .history-list {
      list-style: none;
      padding: 0;
      margin: 0;
      transform: skewX(15deg);
    }

    .history-item {
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 230, 0, 0.2);
      cursor: pointer;
      font-size: 1rem;
      color: #ddd;
    }

    .history-item:hover {
      color: #fff;
      text-shadow: 0 0 5px var(--nfs-yellow);
    }

    .speed-cluster {
      position: relative;
      text-align: right;
      transform: skewX(var(--hud-skew));
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }

    .speed-value {
      font-family: 'Orbitron';
      font-size: 6rem;
      font-weight: 900;
      color: #fff;
      line-height: 0.8;
      text-shadow: 0 0 20px var(--nfs-cyan);
    }

    .speed-label {
      font-family: 'Rajdhani';
      font-size: 1.5rem;
      color: var(--nfs-cyan);
      font-weight: 700;
      margin-right: 10px;
    }

    #car-canvas-container {
      width: 180px;
      height: 100px;
      margin-top: -20px;
      margin-right: -20px;
      opacity: 0.8;
      transform: skewX(15deg);
    }

    /* Route Summary Panel */
    .route-summary {
      background: var(--nfs-dark-trans);
      border-right: 4px solid var(--nfs-cyan);
      padding: 15px;
      width: 250px;
      transform: skewX(var(--hud-skew));
      margin-right: 20px;
      display: none; /* Hidden by default */
    }

    .summary-title {
      color: var(--nfs-cyan);
      font-family: 'Orbitron';
      font-size: 1.1rem;
      border-bottom: 1px solid rgba(0, 243, 255, 0.3);
      padding-bottom: 5px;
      margin-bottom: 10px;
      transform: skewX(15deg);
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 1rem;
      transform: skewX(15deg);
    }

    .summary-label { color: #aaa; }
    .summary-val { color: #fff; font-weight: bold; }
    
    .val-gas { color: var(--nfs-cyan); }
    .val-cam { color: var(--nfs-pink); }
    .val-danger { color: var(--nfs-yellow); }

    @media (max-width: 768px) {
      .speed-value {
        font-size: 4rem;
      }

      .nav-hub {
        width: 100%;
      }
    }
  </style>
</head>

<body>
  <script type="importmap">
    {
        "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
        }
    }
</script>

  <div id="map"></div>

  <!-- HUD -->
  <div class="hud-layer">
    <div class="top-bar">
      <div class="nav-hub hud-element">
        <div class="nav-input-container">
          <span class="nav-label">DESTINATION</span>
          <input type="text" id="nav-input" class="hud-input" placeholder="SEARCH..." />
        </div>
        <div class="search-results" id="search-results"></div>
        <div class="route-panel" id="route-panel">
          <div class="route-row"><span class="route-label">FROM:</span>
            <div class="route-input-box"><input type="text" id="start-input" value="Current Location" /></div>
          </div>
          <div class="route-row"><span class="route-label">TO:</span>
            <div class="route-input-box"><input type="text" id="end-input" readonly /></div>
          </div>
          <button class="btn-go" onclick="startNavigation()">INITIATE ROUTE</button>
          <div class="search-results" id="start-search-results" style="top: 100%; display:none;"></div>
        </div>
      </div>
      <div class="danger-widget hud-element" id="danger-alert">
        <div class="danger-text">! HIGH RISK ZONE !</div>
      </div>
      <div class="route-summary hud-element" id="route-summary">
        <div class="summary-title">ROUTE INTEL</div>
        <div class="summary-row"><span class="summary-label">GAS STATIONS:</span> <span class="summary-val val-gas" id="sum-gas">0</span></div>
        <div class="summary-row"><span class="summary-label">CAMERAS:</span> <span class="summary-val val-cam" id="sum-cam">0</span></div>
        <div class="summary-row"><span class="summary-label">HAZARDS:</span> <span class="summary-val val-danger" id="sum-danger">0</span></div>
        <div class="summary-row" style="margin-top:10px; border-top:1px solid #333; padding-top:5px;">
           <span class="summary-label">NEAREST:</span> <span class="summary-val" id="sum-nearest">--</span>
        </div>
      </div>
    </div>
    <div class="bottom-bar">
      <div class="history-panel hud-element">
        <div class="history-title">RECENT LOCATIONS</div>
        <ul class="history-list" id="history-list">
          <li class="history-item">SYSTEM READY...</li>
        </ul>
      </div>
      <div class="speed-cluster hud-element">
        <div class="speed-value">0</div>
        <div class="speed-label">KM/H</div>
        <div id="car-canvas-container"><canvas id="car-canvas"></canvas></div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // Global config
    const CONFIG = {
      defaultPos: [-58.3816, -34.6037], // Buenos Aires
      theme: { dark: '#0a0f1e', cyan: '#00f3ff', pink: '#ff0055' }
    };

    let currentState = { currentPos: null, startPos: null, endPos: null, endName: "" };
    let destMarker = null;
    let globalMergedData = null; // Store for Route Analysis

    // --- MAP SETUP ---
    const map = new maplibregl.Map({
      container: 'map',
      // Using OpenMapTiles or similar for the base style (NEON Style)
      style: {
        "version": 8,
        "glyphs": "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
        "sources": {
          "osm": { "type": "raster", "tiles": ["https://a.tile.openstreetmap.org/{z}/{x}/{y}.png"], "tileSize": 256, "attribution": "&copy; NFS Map" },
          "openmaptiles": { "type": "vector", "url": "https://api.maptiler.com/tiles/v3-openmaptiles/tiles.json?key=JZURWSSXaezauUK6D94q" }
        },
        "layers": [
          { "id": "background", "type": "background", "paint": { "background-color": "#050510" } },
          { "id": "water", "type": "fill", "source": "openmaptiles", "source-layer": "water", "paint": { "fill-color": "#001a2a" } },
          { "id": "road", "type": "line", "source": "openmaptiles", "source-layer": "transportation", "paint": { "line-color": "#00f3ff", "line-width": 1.5, "line-opacity": 0.4 } },
          { "id": "building-3d", "type": "fill-extrusion", "source": "openmaptiles", "source-layer": "building", "paint": { "fill-extrusion-color": "#0a0f1e", "fill-extrusion-height": ["get", "render_height"], "fill-extrusion-base": ["get", "render_min_height"], "fill-extrusion-opacity": 0.8 } }
        ]
      },
      zoom: 14,
      center: CONFIG.defaultPos,
      pitch: 60,
      canvasContextAttributes: { antialias: true }
    });



    map.on('load', () => {
      // locateUser(); // Disabled auto-locate on load to prevent violation
      loadData();
    });

    // --- DATA LOADING & CLUSTERING ---
    async function loadData() {
      const loadIcon = async (name, url, fallbackColor) => {
        if (map.hasImage(name)) return;
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status} - ${response.statusText}`);
            const blob = await response.blob();
            
            const img = new Image();
            const objectUrl = URL.createObjectURL(blob);
            
            await new Promise((resolve, reject) => {
                img.onload = () => {
                    // Resize to standard 48px (for 12px render with 0.25 scale)
                    const canvas = document.createElement('canvas');
                    canvas.width = 128; canvas.height = 128;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, 128, 128);
                    
                    map.addImage(name, canvas.getContext('2d').getImageData(0,0,128,128));
                    URL.revokeObjectURL(objectUrl);
                    resolve();
                };
                img.onerror = (e) => {
                    URL.revokeObjectURL(objectUrl);
                    reject(new Error('Image load failed'));
                };
                img.src = objectUrl;
            });

        } catch (err) {
            console.warn(`Failed to load icon ${name} from ${url} (Error: ${err.message}), using fallback.`);
            const canvas = document.createElement('canvas');
            canvas.width = 48; canvas.height = 48;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = fallbackColor;
            ctx.beginPath();
            ctx.arc(24, 24, 20, 0, Math.PI * 2); // adjusted for 48px
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
            if (!map.hasImage(name)) {
                map.addImage(name, canvas.getContext('2d').getImageData(0,0,48,48));
            }
        }
      };

      await Promise.all([
        loadIcon('gnc-icon', './assets/iconos/gnc.svg', '#00f3ff'),
        loadIcon('pump-icon', './assets/iconos/surtidornafta.svg', '#00f3ff'),
        loadIcon('cam-icon', './assets/iconos/speedcamera.svg', '#ff0055')
      ]);


      console.log("Images (or fallbacks) loaded.");
      fetchDataAndCluster();
    }

    function fetchDataAndCluster() {
      const safeFetch = (url) => fetch(url)
        .then(r => {
            if (!r.ok) throw new Error(r.statusText);
            return r.json();
        })
        .catch(e => {
            console.warn(`Failed to fetch ${url}:`, e);
            return { type: "FeatureCollection", features: [] };
        });

      const pGas = safeFetch('./estaciones%20de%20servicio/estaciones_servicio_argentina.geojson');
      const pCam = safeFetch('./fotomultas/speed_cameras.geojson');
      const pVilla = safeFetch('./villas/renabap-2023-12-06.geojson');

      Promise.all([pGas, pCam, pVilla]).then(([gasData, camData, villaData]) => {
        const features = [];

        // 1. Process Gas Stations
        if (gasData.features) {
            gasData.features.forEach(f => {
              const isGNC = f.properties.tipooperador && f.properties.tipooperador.toLowerCase().includes('gnc');
              f.properties.type = 'gas';
              f.properties.fuel_type = isGNC ? 'gnc' : 'liquid';
              f.properties.gasCount = 1; 
              f.properties.cameraCount = 0;
              f.properties.villaCount = 0;
              features.push(f);
            });
        }

        // 2. Process Cameras
        if (camData.features) {
            camData.features.forEach(f => {
              f.properties.type = 'camera';
              f.properties.gasCount = 0;
              f.properties.cameraCount = 1;
              f.properties.villaCount = 0;
              features.push(f);
            });
        }

        // 3. Process Villas
        if (villaData.features) {
             if (!map.getSource('danger-zone')) {
                 map.addSource('danger-zone', { type: 'geojson', data: villaData });
                 map.addLayer({
                   'id': 'danger-fill',
                   'type': 'fill',
                   'source': 'danger-zone',
                   'paint': { 'fill-color': '#ff0055', 'fill-opacity': 0.3 }
                 });
                 map.on('click', 'danger-fill', (e) => {
                   const props = e.features[0].properties || {};
                   new maplibregl.Popup()
                     .setLngLat(e.lngLat)
                     .setHTML(`
                         <div style="color:red; font-family:sans-serif;">
                             <h3 style="margin:0;">DANGER ZONE</h3>
                             <p>${props.nombre_barrio || props.nombre || 'Caution Area'}</p>
                         </div>
                     `)
                     .addTo(map);
                 });
             }
    
            villaData.features.forEach(f => {
              const center = turf.centroid(f);
              if (center) {
                center.properties = { ...f.properties };
                center.properties.type = 'villa';
                center.properties.gasCount = 0;
                center.properties.cameraCount = 0;
                center.properties.villaCount = 1;
                features.push(center);
              }
            });
        }

        const mergedData = {
          type: "FeatureCollection",
          features: features
        };
        globalMergedData = mergedData;

        setupClusteredSource(mergedData);

      }).catch(err => console.error("Data Load Error:", err));
    }

    function setupClusteredSource(data) {
        if (map.getSource('merged-data')) return; // Avoid duplicate add

        map.addSource('merged-data', {
            type: 'geojson',
            data: data,
            cluster: true,
            clusterRadius: 80,
            clusterProperties: {
                'gas': ['+', ['get', 'gasCount']],
                'cam': ['+', ['get', 'cameraCount']],
                'villa': ['+', ['get', 'villaCount']]
            }
        });

        // --- Unclustered Layers ---
        map.addLayer({
            id: 'unclustered-gas',
            type: 'symbol',
            source: 'merged-data',
            filter: ['all', ['!has', 'point_count'], ['==', 'type', 'gas']],
            layout: {
                'icon-image': ['case', ['==', ['get', 'fuel_type'], 'gnc'], 'gnc-icon', 'pump-icon'],
                'icon-size': 0.25,
                'icon-allow-overlap': true
            }
        });

        map.addLayer({
            id: 'unclustered-cam',
            type: 'symbol',
            source: 'merged-data',
            filter: ['all', ['!has', 'point_count'], ['==', 'type', 'camera']],
            layout: {
                'icon-image': 'cam-icon',
                'icon-size': 0.25,
                'icon-allow-overlap': true
            }
        });
        
        // Trigger marker updates
        map.on('data', (e) => {
            if (e.sourceId !== 'merged-data' || !e.isSourceLoaded) return;
            map.on('move', updateMarkers);
            map.on('moveend', updateMarkers);
            updateMarkers();
        });

        // --- Popups ---
        map.on('click', 'unclustered-gas', (e) => {
             const props = e.features[0].properties;
             new maplibregl.Popup()
               .setLngLat(e.lngLat)
               .setHTML(`
                     <div style="color:black; font-family:sans-serif;">
                         <h3 style="margin:0;">${props.empresabandera || 'Gas Station'}</h3>
                         <p style="margin:5px 0;">${props.tipooperador || 'Fuel'}</p>
                         <p style="font-size:0.8em; color:gray;">${props.direccion || ''}</p>
                     </div>
                 `)
               .addTo(map);
        });
        map.on('mouseenter', 'unclustered-gas', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'unclustered-gas', () => map.getCanvas().style.cursor = '');

        map.on('click', 'unclustered-cam', (e) => {
             const props = e.features[0].properties;
             const address = props.calleRuta || props.ubicacion || props.direccion || 'Location Unknown';
             new maplibregl.Popup()
               .setLngLat(e.lngLat)
               .setHTML(`
                     <div style="color:darkred; font-family:sans-serif;">
                         <h3 style="margin:0;">⚠️ CAMERA</h3>
                         <p style="margin:5px 0; font-size:0.9em; color:#333;">${address}</p>
                         <p style="margin:5px 0;">MAX SPEED: <b>${props.velocidadPermitida || 'N/A'} KM/H</b></p>
                     </div>
                 `)
               .addTo(map);
        });
        map.on('mouseenter', 'unclustered-cam', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'unclustered-cam', () => map.getCanvas().style.cursor = '');
    }

    // --- CLUSTERING VISUALIZATION ---
    const markers = {};
    let markersOnScreen = {};

    function updateMarkers() {
        const newMarkers = {};
        const features = map.querySourceFeatures('merged-data');

        for (let i = 0; i < features.length; i++) {
            const coords = features[i].geometry.coordinates;
            const props = features[i].properties;
            if (!props.cluster) continue;
            const id = props.cluster_id;

            let marker = markers[id];
            if (!marker) {
                const el = createDonutChart(props);
                marker = markers[id] = new maplibregl.Marker({
                    element: el
                }).setLngLat(coords);
            }
            newMarkers[id] = marker;

            if (!markersOnScreen[id]) marker.addTo(map);
        }
        for (let id in markersOnScreen) {
            if (!newMarkers[id]) markersOnScreen[id].remove();
        }
        markersOnScreen = newMarkers;
    }

    function createDonutChart(props) {
        const offsets = [];
        const counts = [
            props.gas || 0,
            props.cam || 0,
            props.villa || 0
        ];
        
        let total = 0;
        for (let i = 0; i < counts.length; i++) {
            offsets.push(total);
            total += counts[i];
        }
        const fontSize = total >= 1000 ? 22 : total >= 100 ? 20 : total >= 10 ? 18 : 16;
        const r = total >= 1000 ? 50 : total >= 100 ? 32 : total >= 10 ? 24 : 18;
        const r0 = Math.round(r * 0.6);
        const w = r * 2;

        let html = `<div><svg width="${w}" height="${w}" viewbox="0 0 ${w} ${w}" text-anchor="middle" style="font: ${fontSize}px sans-serif; display: block">`;

        const colors = ['#00f3ff', '#ff0055', '#ffe600']; 

        for (let i = 0; i < counts.length; i++) {
            if (counts[i] > 0) { 
                 html += donutSegment(
                    offsets[i] / total,
                    (offsets[i] + counts[i]) / total,
                    r,
                    r0,
                    colors[i]
                );
            }
        }
        html += `<circle cx="${r}" cy="${r}" r="${r0}" fill="#0a0f1e" />
                 <text dominant-baseline="central" transform="translate(${r}, ${r})" fill="white" style="font-family:'Orbitron'">${total.toLocaleString()}</text></svg></div>`;

        const el = document.createElement('div');
        el.innerHTML = html;
        return el.firstChild;
    }

    function donutSegment(start, end, r, r0, color) {
        if (isNaN(start) || isNaN(end)) return '';
        if (end - start === 1) end -= 0.00001;
        const a0 = 2 * Math.PI * (start - 0.25);
        const a1 = 2 * Math.PI * (end - 0.25);
        const x0 = Math.cos(a0), y0 = Math.sin(a0);
        const x1 = Math.cos(a1), y1 = Math.sin(a1);
        const largeArc = end - start > 0.5 ? 1 : 0;

        return `<path d="M ${r + r0 * x0} ${r + r0 * y0} L ${r + r * x0} ${r + r * y0} A ${r} ${r} 0 ${largeArc} 1 ${r + r * x1} ${r + r * y1} L ${r + r0 * x1} ${r + r0 * y1} A ${r0} ${r0} 0 ${largeArc} 0 ${r + r0 * x0} ${r + r0 * y0}" fill="${color}" />`;
    }


    // --- UTILS for HUD ---
    // --- SEARCH LOGIC ---
    const navInput = document.getElementById('nav-input');
    const searchResults = document.getElementById('search-results');
    const routePanel = document.getElementById('route-panel');
    const endInput = document.getElementById('end-input');

    // Add Locate Button Logic
    const locateBtn = document.createElement('button');
    locateBtn.innerHTML = '&oplus;'; // Target icon
    locateBtn.title = "Locate Me";
    locateBtn.style.cssText = "position:absolute; right:10px; top:50%; transform:translateY(-50%); background:transparent; border:none; color:var(--nfs-cyan); font-size:1.2rem; cursor:pointer;";
    document.querySelector('.nav-input-container').appendChild(locateBtn);
    
    locateBtn.addEventListener('click', locateUser);

    let debounceTimer;
    if (navInput) {
      navInput.addEventListener('input', (e) => {
        const query = e.target.value;
        clearTimeout(debounceTimer);
        if (query.length < 3) {
          searchResults.style.display = 'none';
          return;
        }

        debounceTimer = setTimeout(() => {
          fetch('https://nominatim.openstreetmap.org/search?format=json&q=' + encodeURIComponent(query))
            .then(res => res.json())
            .then(data => {
              searchResults.innerHTML = '';
              if (data.length > 0) {
                searchResults.style.display = 'block';
                data.forEach(item => {
                  const div = document.createElement('div');
                  div.className = 'result-item';
                  div.textContent = item.display_name;
                  div.addEventListener('click', () => {
                    // Select Item
                    currentState.endPos = [parseFloat(item.lon), parseFloat(item.lat)];
                    currentState.endName = item.display_name;

                    // Update UI
                    searchResults.style.display = 'none';
                    navInput.value = '';
                    routePanel.style.display = 'block';
                    endInput.value = item.display_name;

                    // Marker
                    if (destMarker) destMarker.remove();
                    destMarker = new maplibregl.Marker({ color: '#ff0055' })
                      .setLngLat(currentState.endPos)
                      .addTo(map);

                    map.flyTo({ center: currentState.endPos, zoom: 14 });
                  });
                  searchResults.appendChild(div);
                });
              } else {
                searchResults.style.display = 'none';
              }
            })
            .catch(err => console.error("Search Error:", err));
        }, 500);
      });
    }

    let watchId = null;
    let userMarker = null;

    function startDriving() {
        if (!("geolocation" in navigator)) return;
        
        if (watchId) navigator.geolocation.clearWatch(watchId);

        const options = {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 5000
        };

        watchId = navigator.geolocation.watchPosition((pos) => {
            const coords = [pos.coords.longitude, pos.coords.latitude];
            const speedMps = pos.coords.speed || 0;
            const speedKmh = Math.round(speedMps * 3.6);
            const heading = pos.coords.heading;

            currentState.currentPos = coords;

            map.flyTo({
                center: coords,
                zoom: 17,
                bearing: heading || 0,
                pitch: 60,
                speed: 1.5,
                curve: 1
            });

            if (userMarker) {
                userMarker.setLngLat(coords);
            } else {
                userMarker = new maplibregl.Marker({ color: '#00f3ff' }).setLngLat(coords).addTo(map);
            }
            
            const speedValEl = document.querySelector('.speed-value');
            if (speedValEl) speedValEl.textContent = speedKmh;

        }, (err) => {
            console.warn("Drive Mode Error:", err);
        }, options);
    }

    window.startNavigation = function () {
      startDriving();
      if (!currentState.startPos && currentState.currentPos) {
        currentState.startPos = currentState.currentPos;
      }

      if (!currentState.startPos || !currentState.endPos) {
        alert("Please select a valid start and end point (or wait for geolocation).");
        return;
      }

      // Fetch Route from OSRM
      const start = currentState.startPos;
      const end = currentState.endPos;
      const url = `https://router.project-osrm.org/route/v1/driving/${start[0]},${start[1]};${end[0]},${end[1]}?overview=full&geometries=geojson`;

      fetch(url)
        .then(res => res.json())
        .then(data => {
          if (data.routes && data.routes.length > 0) {
            const route = data.routes[0];
            const geojson = {
              type: 'Feature',
              properties: {},
              geometry: route.geometry
            };

            if (map.getSource('route')) {
              map.getSource('route').setData(geojson);
            } else {
              map.addSource('route', {
                type: 'geojson',
                data: geojson
              });
              map.addLayer({
                id: 'route',
                type: 'line',
                source: 'route',
                layout: {
                  'line-join': 'round',
                  'line-cap': 'round'
                },
                paint: {
                  'line-color': '#ffe600', // Yellow for route
                  'line-width': 5,
                  'line-opacity': 0.8,
                  'line-blur': 1
                }
              });
              // Add a glow effect
              map.addLayer({
                id: 'route-glow',
                type: 'line',
                source: 'route',
                layout: {
                  'line-join': 'round',
                  'line-cap': 'round'
                },
                paint: {
                  'line-color': '#ffe600',
                  'line-width': 10,
                  'line-opacity': 0.3,
                  'line-blur': 10
                }
              }, 'route'); // draw glow behind
            }

            // Fit bounds
            const bounds = new maplibregl.LngLatBounds();
            route.geometry.coordinates.forEach(coord => bounds.extend(coord));
            map.fitBounds(bounds, {
              padding: 100
            });

            // --- ROUTE ANALYSIS ---
            if (globalMergedData) {
                const routeSummary = document.getElementById('route-summary');
                routeSummary.style.display = 'block'; // Show panel

                // Create buffer (e.g. 0.5km)
                const buffered = turf.buffer(geojson, 0.5, { units: 'kilometers' });
                
                // Find points within buffer
                const pointsWithin = turf.pointsWithinPolygon(globalMergedData, buffered);

                // Stats
                let gasCount = 0;
                let camCount = 0;
                let villaCount = 0;
                let nearestDist = Infinity;
                let nearestLabel = "--";

                const startPt = turf.point(currentState.startPos);

                pointsWithin.features.forEach(pt => {
                    const type = pt.properties.type;
                    if (type === 'gas') gasCount++;
                    if (type === 'camera') camCount++;
                    if (type === 'villa') villaCount++;

                    // Distance from start
                    const d = turf.distance(startPt, pt, { units: 'kilometers' });
                    if (d < nearestDist && d > 0.1) { // Ignore immediate start items if any
                        nearestDist = d;
                        if (type === 'gas') nearestLabel = "Gas Station (" + d.toFixed(1) + "km)";
                        if (type === 'camera') nearestLabel = "Camera (" + d.toFixed(1) + "km)";
                        if (type === 'villa') nearestLabel = "Danger Zone (" + d.toFixed(1) + "km)";
                    }
                });

                document.getElementById('sum-gas').textContent = gasCount;
                document.getElementById('sum-cam').textContent = camCount;
                document.getElementById('sum-danger').textContent = villaCount;
                document.getElementById('sum-nearest').textContent = nearestLabel;
            }

          } else {
            alert("No route found.");
          }
        })
        .catch(err => {
          console.error("Routing error:", err);
          alert("Error fetching route.");
        });
    };

    function locateUser() {
      if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(position => {
          const pos = [position.coords.longitude, position.coords.latitude];
          currentState.currentPos = pos;
          map.flyTo({ center: pos, zoom: 15 });
          
          if (userMarker) userMarker.remove();
          userMarker = new maplibregl.Marker({ color: '#00f3ff' }).setLngLat(pos).addTo(map);
        });
      }
    }

    // 3D Car Widget
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

    const carCanvas = document.getElementById('car-canvas');
    if (carCanvas) {
      const renderer = new THREE.WebGLRenderer({ canvas: carCanvas, alpha: true, antialias: true });
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, 180 / 100, 0.1, 1000);
      camera.position.set(200, 100, 300); // Zoom out a bit for the model
      camera.lookAt(0, 0, 0);

      // Light for base visibility
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(5, 10, 7);
      scene.add(dirLight);

      let carGroup = new THREE.Group();
      scene.add(carGroup);

      const loader = new FBXLoader();
      loader.load('./assets/20251214021233_3c4724df.fbx', (object) => {
        // STYLE: Simplified Orange Lines (Technical Look)
        const lineMat = new THREE.LineBasicMaterial({
          color: 0xffa500, // Orange
        });

        object.traverse((child) => {
          if (child.isMesh) {
            // Create simplified edges (threshold 15 degrees)
            const edges = new THREE.EdgesGeometry(child.geometry, 15);
            const line = new THREE.LineSegments(edges, lineMat);

            // Add lines as a child of the mesh
            child.add(line);

            // Hide the original solid faces
            child.material = new THREE.MeshBasicMaterial({ visible: false });
          }
        });

        // Center and Scale
        const box = new THREE.Box3().setFromObject(object);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        // Auto-scale to fit roughly in view
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 150 / maxDim; // Target size 150 units

        object.position.x = -center.x; // Center it
        object.position.y = -center.y;
        object.position.z = -center.z;

        object.scale.set(scale, scale, scale);

        carGroup.add(object);
      }, undefined, (error) => {
        console.error("Error loading car FBX:", error);
      });

      function animateCar() {
        requestAnimationFrame(animateCar);
        if (carGroup) carGroup.rotation.y += 0.01;
        renderer.render(scene, camera);
      }
      animateCar();
    }

  </script>
</body>

</html>