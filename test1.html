<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Neon Drive Map UI</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <!-- Maplibre GL JS library for the interactive map -->
  <script src="https://unpkg.com/maplibre-gl@5.5.0/dist/maplibre-gl.js"></script>
  <link href="https://unpkg.com/maplibre-gl@5.5.0/dist/maplibre-gl.css" rel="stylesheet" />
  <!-- Geocoder plugin for MapLibre -->
  <script src="https://unpkg.com/@maplibre/maplibre-gl-geocoder@1.5.0/dist/maplibre-gl-geocoder.min.js"></script>
  <link href="https://unpkg.com/@maplibre/maplibre-gl-geocoder@1.5.0/dist/maplibre-gl-geocoder.css" rel="stylesheet" />
<!-- Three.js for the 3D car model -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- OrbitControls to allow the user to rotate the 3D model -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.127.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>


  <!-- inlcude manifest -->
  <link rel="manifest" href="manifest.json">

    <meta name="viewport" content="initial-scale=1, viewport-fit=cover, width=device-width"></meta>
  <meta name="apple-mobile-web-app-capable" content="yes"></meta>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"></meta>

  <style>

    /* styles.css */
html {
  min-height: calc(100% + env(safe-area-inset-top));
  padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);



  background-attachment: fixed;
  background-image: url('/bg.svg');
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
}

    /* Global styles for the retro-futuristic theme */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Courier New', Courier, monospace;
      background-color: #0d0d1a; /* Dark blue-purple b  ackground */
      color: #00ffcc; /* Neon green for text */
      overflow: hidden;
      font-size: 14px;
    }

    /* Style for the main map container */
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
      /* Use a filter to give the map a synthetic, high-contrast look */
      /*
      */
      filter: saturate(1.5) hue-rotate(180deg);
    }

    /* Overlay for the main title and branding */
    .map-overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(13, 13, 26, 0.8);
      padding: 10px 20px;
      border: 2px solid #00ffcc;
      box-shadow: 0 0 15px #00ffcc;
      z-index: 10;
      border-radius: 8px;
    }
    .map-overlay h1 {
      margin: 0;
      font-size: 2em;
      color: #00ccff;
      text-shadow: 0 0 10px #00ccff;
    }
    .map-overlay p {
      margin: 5px 0 0 0;
      color: #ff00cc;
      text-shadow: 0 0 5px #ff00cc;
    }

    /* Container for the clickable track list */
    .track-list {
      position: absolute;
      bottom: 50px;
      left: 50px;
      width: 250px;
      background: rgba(13, 13, 26, 0.8);
      border: 2px solid #ff00cc;
      box-shadow: 0 0 15px #ff00cc;
      z-index: 10;
      padding: 10px;
      border-radius: 8px;
    }
    .track-list h3 {
      color: #ff00cc;
      text-shadow: 0 0 5px #ff00cc;
      margin-top: 0;
    }
    .track-list ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .track-list li {
      padding: 8px;
      border-bottom: 1px solid rgba(255, 0, 204, 0.3);
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
    }
    .track-list li:last-child {
      border-bottom: none;
    }
    .track-list li:hover {
      background-color: rgba(255, 0, 204, 0.2);
      transform: translateX(5px);
    }
    .track-list li.active {
      background-color: rgba(255, 0, 204, 0.4);
      text-shadow: 0 0 5px #ff00cc;
      color: #fff;
    }

    /* Container for the 3D car model */
    .car-model-container {
      position: absolute;
      bottom: 50px;
      right: 50px;
      width: 200px;
      height: 200px;
      background: rgba(13, 13, 26, 0.8);
      border: 2px solid #00ccff;
      box-shadow: 0 0 20px #00ccff;
      z-index: 10;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
    }

    /* Routing Controls Overlay */
    .routing-controls {
      position: absolute;
      top: 20px;
      right: 320px;
      background: rgba(13,13,26,0.85);
      border: 2px solid #00ccff;
      box-shadow: 0 0 10px #00ccff;
      border-radius: 8px;
      z-index: 20;
      padding: 12px 18px;
      color: #00ffcc;
      font-family: inherit;
    }
    .routing-controls div {
      margin-bottom: 8px;
    }
    .routing-controls label {
      display: block;
      margin-bottom: 4px;
    }
    .routing-controls input, .routing-controls select {
      padding: 8px;
      border: 1px solid #00ccff;
      border-radius: 4px;
      background: rgba(0, 204, 255, 0.1);
      color: #00ccff;
      width: 100%;
    }
    .routing-controls button {
      background: #ff00cc;
      color: #fff;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .routing-controls button:hover {
      background: #e60099;
    }

    /* Responsive adjustments for smaller screens */
    @media (max-width: 768px) {
      .map-overlay {
        top: 10px;
        left: 10px;
        padding: 8px 15px;
      }
      .map-overlay h1 {
        font-size: 1.5em;
      }
      .track-list, .car-model-container {
        bottom: 10px;
        width: 45%;
        left: 10px;
        right: 10px;
      }
      .car-model-container {
        right: 10px;
        left: auto;
      }
      .routing-controls {
        right: 10px;
        left: auto;
        width: 90%;
        top: auto;
        bottom: 10px;
      }
    }

        /* --- Basic Setup --- */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Orbitron', sans-serif;
            background-color: #121212;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        /* --- Custom Controls General Container --- */
        .custom-controls-container {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px; /* Spacing between geocoder and nav buttons */
            z-index: 1;
        }

        /* --- Custom Geocoder --- */
        .custom-geocoder-container {
            position: relative;
            width: 250px;
        }

        #geocoder-input {
            width: 100%;
            padding: 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            color: #f0f0f0;
            background-color: rgba(10, 10, 25, 0.8);
            border: 1px solid #00ffff;
            border-radius: 8px;
            box-shadow: 
                0 0 5px #00ffff, 
                0 0 10px #00ffff, 
                0 0 15px #ff00cc,
                inset 0 0 5px rgba(0, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            outline: none;
            transition: all 0.2s ease-in-out;
        }
        
        #geocoder-input::placeholder {
            color: #00ffff;
            opacity: 0.6;
        }

        #geocoder-results {
            position: absolute;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            background-color: rgba(10, 10, 25, 0.9);
            border: 1px solid #00ffff;
            border-radius: 8px;
            margin-top: 8px;
            box-shadow: 0 0 5px #00ffff, 0 0 10px #ff00cc;
            backdrop-filter: blur(5px);
        }

        .geocoder-suggestion {
            padding: 12px 15px;
            color: #f0f0f0;
            cursor: pointer;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            transition: background-color 0.2s ease;
        }
        
        .geocoder-suggestion:last-child {
            border-bottom: none;
        }

        .geocoder-suggestion:hover {
            background-color: rgba(255, 0, 204, 0.2);
        }

        /* --- Custom Navigation Controls Container --- */
        .custom-nav-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end; /* Align to the right */
        }

        /* --- General Button Style --- */
        .neon-map-button {
            width: 40px;
            height: 40px;
            background-color: rgba(10, 10, 25, 0.8);
            border: 1px solid #00ffff;
            border-radius: 8px;
            color: #00ffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            transition: all 0.2s ease-in-out;
            box-shadow: 
                0 0 5px #00ffff, 
                0 0 10px #00ffff, 
                0 0 15px #ff00cc,
                inset 0 0 5px rgba(0, 255, 255, 0.5);
            backdrop-filter: blur(5px);
        }

        .neon-map-button:hover {
            background-color: rgba(255, 0, 204, 0.3);
            color: #ffffff;
            transform: scale(1.1);
            box-shadow: 
                0 0 8px #ff00cc, 
                0 0 15px #ff00cc, 
                0 0 25px #ff00cc,
                inset 0 0 8px rgba(255, 0, 204, 0.6);
        }
        
        .neon-map-button:active {
            transform: scale(1.05);
        }

        /* --- Compass Icon Styling --- */
        #compass-btn svg {
            width: 24px;
            height: 24px;
            fill: #00ffff;
            transition: transform 0.3s ease-in-out, fill 0.2s;
        }
        
        #compass-btn:hover svg {
            fill: #ffffff;
        }
  </style>
</head>
<body>

  <!-- The MapLibre map container -->
  <div id="map"></div>

  <!-- UI Overlays -->
  <div class="map-overlay">
    <h1>NEON DRIVE</h1>
    <p>Select a circuit to begin...</p>
  </div>

  <div class="track-list">
    <h3>CIRCUITS</h3>
    <ul id="track-menu">



      <li data-lat="37.797735" data-lon="-122.418774" class="active">San Francisco Circuit</li>
      <li data-lat="34.052235" data-lon="-118.243683">Los Angeles Loop</li>
      <li data-lat="-34.603851" data-lon="-58.381775">Buenos Aires</li>
    </ul>
  </div>

  <div class="car-model-container">
    <canvas id="car-canvas"></canvas>
  </div>

  <!-- Routing Controls Overlay -->
  <div class="routing-controls">
    <div>
      <label for="start-coord">Start:</label>
      <input id="start-coord" type="text" placeholder="Click map or search" style="width:120px;">
    </div>
    <div>
      <label for="target-coord">Target:</label>
      <input id="target-coord" type="text" placeholder="Click map or search" style="width:120px;">
    </div>
    <div>
      <label for="transport">Transport:</label>
      <select id="transport">
        <option value="auto">Car</option>
        <option value="bicycle">Bicycle</option>
        <option value="pedestrian">Walk</option>
      </select>
      <button id="route-btn" style="margin-left:10px;background:#ff00cc;color:#fff;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;">Route</button>
    </div>
  </div>

  <!-- Add this button inside your HTML body, after the map div, for "Neon Drive" style -->
<button id="gps-btn" style="
  position: absolute;
  bottom: 20px;
  right: 20px;
  z-index: 40;
  background: rgba(13,13,26,0.95);
  border: 2px solid #00ffcc;
  box-shadow: 0 0 15px #00ffcc;
  border-radius: 50%;
  width: 56px;
  height: 56px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: box-shadow 0.3s;
">
  <svg width="32" height="32" viewBox="0 0 24 24" fill="none">
    <circle cx="12" cy="12" r="5" stroke="#00ffcc" stroke-width="2" fill="#0d0d1a"/>
    <path d="M12 2v3M12 19v3M2 12h3M19 12h3" stroke="#ff00cc" stroke-width="2" stroke-linecap="round"/>
  </svg>
</button>


    <!-- The Custom HTML Controls Container -->
    <div class="custom-controls-container">
        <!-- Custom Geocoder -->
        <div class="custom-geocoder-container">
            <input type="text" id="geocoder-input" placeholder="Search location...">
            <div id="geocoder-results"></div>
        </div>
        <!-- Custom Navigation Controls -->
        <div class="custom-nav-controls">
            <button id="zoom-in-btn" class="neon-map-button" aria-label="Zoom in">+</button>
            <button id="zoom-out-btn" class="neon-map-button" aria-label="Zoom out">-</button>
            <button id="compass-btn" class="neon-map-button" aria-label="Reset bearing to north">
                <svg id="compass-arrow" viewBox="0 0 24 24">
                    <path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/>
                </svg>
            </button>
        </div>
    </div>

<script>
  document.getElementById('gps-btn').onclick = function() {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(function(pos) {
        map.flyTo({
          center: [pos.coords.longitude, pos.coords.latitude],
          zoom: 14
        });
      });
    } else {
      alert('Geolocation is not supported by your browser.');
    }
  };
</script>

  <script>
    window.navigator.standalone

    // Three.js setup for the rotatable car model
    const carContainer = document.getElementById('car-canvas');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, carContainer.clientWidth / carContainer.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: carContainer, alpha: true });
    renderer.setSize(carContainer.clientWidth, carContainer.clientHeight);

    // Create a simple car model (a box)
    const geometry = new THREE.BoxGeometry(1, 0.5, 2);
    // Use a neon material that glows
    const material = new THREE.MeshStandardMaterial({ color: 0x00ccff, metalness: 0.8, roughness: 0.2 });
    const car = new THREE.Mesh(geometry, material);
    scene.add(car);

    // Add lighting to the scene
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    camera.position.z = 3;

    // Add OrbitControls to enable user-driven rotation with the mouse
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableZoom = false;
    controls.enablePan = false;

    // The animation loop to constantly render the 3D scene
    const animate = () => {
      requestAnimationFrame(animate);
      controls.update(); // Update controls in each frame
      renderer.render(scene, camera);
    };
    animate();

    // Maplibre GL JS setup for the retro-futuristic map
    const map = new maplibregl.Map({
      container: 'map',
      style: {
  "version": 8,
  "metadata": {"maputnik:renderer": "mlgljs"},
  "projection": {"type": "globe"},
  "sources": {
    "openmaptiles": {
      "type": "vector",
      "url": "https://api.maptiler.com/tiles/v3-openmaptiles/tiles.json?key=JZURWSSXaezauUK6D94q"
    }
  },
  "layers": [
    {
      "id": "background",
      "type": "background",
      "paint": {"background-color": "#0d0d1a"}
    },
    {
      "id": "water",
      "type": "fill",
      "source": "openmaptiles",
      "source-layer": "water",
      "paint": {"fill-color": "#002a3a"}
    },
    {
      "id": "road_casing",
      "type": "line",
      "source": "openmaptiles",
      "source-layer": "transportation",
      "paint": {
              "line-color": "#ff00cc",
              "line-width": 1,
              "line-opacity": 0.5
      }
    },
    {
      "id": "road",
      "type": "line",
      "source": "openmaptiles",
      "source-layer": "transportation",
      "paint": {
        "line-color": "rgba(0, 255, 204, 1)",
        "line-width": 1,
        "line-opacity": 0.7
      }
    },
    {
      "id": "buildings",
      "type": "fill",
      "source": "openmaptiles",
      "source-layer": "building",
      "paint": {"fill-color": "rgba(0, 255, 204, 0.18)", "fill-opacity": 0.7}
    }
  ],
  "id": "rt6nxgj"
},
      center: [-122.41877447993727, 37.7977350127602],
      zoom: 10.4,
      pitch: 60,
      bearing: -30
    });


    /*
    map.on('load', () => {
      map.addControl(new maplibregl.NavigationControl());
    });*/


        // --- Custom Controls Logic ---
        map.on('load', () => {
            // Instead of map.addControl, we add event listeners to our HTML buttons

            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const compassBtn = document.getElementById('compass-btn');
            const compassArrow = document.getElementById('compass-arrow');

            // 1. Zoom In functionality
            zoomInBtn.addEventListener('click', () => {
                map.zoomIn({ duration: 300 });
            });

            // 2. Zoom Out functionality
            zoomOutBtn.addEventListener('click', () => {
                map.zoomOut({ duration: 300 });
            });

            // 3. Compass (Reset North) functionality
            compassBtn.addEventListener('click', () => {
                map.resetNorth({ duration: 500 });
            });
            
            // 4. Update compass arrow rotation as the map rotates
            map.on('rotate', () => {
                const bearing = map.getBearing();
                compassArrow.style.transform = `rotate(${bearing}deg)`;
            });
        });


    // --- Geocoder integration ---
    const geocoderApi = {
      forwardGeocode: async (config) => {
        const features = [];
        try {
          const request =
            `https://nominatim.openstreetmap.org/search?q=${
              config.query
            }&format=geojson&polygon_geojson=1&addressdetails=1`;
          const response = await fetch(request);
          const geojson = await response.json();
          for (const feature of geojson.features) {
            const center = [
              feature.bbox[0] +
                (feature.bbox[2] - feature.bbox[0]) / 2,
              feature.bbox[1] +
                (feature.bbox[3] - feature.bbox[1]) / 2
            ];
            const point = {
              type: 'Feature',
              geometry: {
                type: 'Point',
                coordinates: center
              },
              place_name: feature.properties.display_name,
              properties: feature.properties,
              text: feature.properties.display_name,
              place_type: ['place'],
              center
            };
            features.push(point);
          }
        } catch (e) {
          console.error(`Failed to forwardGeocode with error: ${e}`);
        }
        return { features };
      }
    };
/*
    map.addControl(
      new MaplibreGeocoder(geocoderApi, {
        maplibregl,
        showResultMarkers: true,
        markerOptions: { color: "#ff00cc" }
      }),
      'top-right'
    );*/





            map.on('load', () => {
            // --- Custom Geocoder Logic ---
            const geocoderInput = document.getElementById('geocoder-input');
            const geocoderResults = document.getElementById('geocoder-results');
            let searchTimeout;

            geocoderInput.addEventListener('input', (e) => {
                // Clear previous timeout
                clearTimeout(searchTimeout);
                // Set a new timeout to avoid spamming the API
                searchTimeout = setTimeout(async () => {
                    const query = e.target.value;
                    geocoderResults.innerHTML = ''; // Clear previous results

                    if (query.length < 3) {
                        return;
                    }

                    const { features } = await geocoderApi.forwardGeocode({ query });

                    features.forEach(feature => {
                        const suggestionEl = document.createElement('div');
                        suggestionEl.className = 'geocoder-suggestion';
                        suggestionEl.textContent = feature.place_name;
                        suggestionEl.addEventListener('click', () => {
                            map.flyTo({
                                center: feature.center,
                                zoom: 14,
                                duration: 2000
                            });
                            // Add a marker
                            new maplibregl.Marker({ color: "#ff00cc" })
                                .setLngLat(feature.center)
                                .addTo(map);
                            
                            // Clear results and input
                            geocoderInput.value = '';
                            geocoderResults.innerHTML = '';
                        });
                        geocoderResults.appendChild(suggestionEl);
                    });
                }, 500); // Debounce time: 500ms
            });
        });
/* GPS button to center map on user's location 
    map.addControl(
      new maplibregl.Control({
        onAdd: function(map) {
          const btn = document.createElement('button');
          btn.id = 'gps-btn';
          btn.style.position = 'absolute';
          btn.style.bottom = '20px';
          btn.style.right = '20px';
          btn.style.zIndex = '30';
          btn.style.background = 'white';
          btn.style.border = 'none';
          btn.style.borderRadius = '50%';
          btn.style.width = '48px';
          btn.style.height = '48px';
          btn.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
          btn.style.cursor = 'pointer';
          btn.style.display = 'flex';
          btn.style.alignItems = 'center';
          btn.style.justifyContent = 'center';
          btn.innerHTML = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
              <circle cx="12" cy="12" r="4" stroke="#222" stroke-width="2" fill="#fff"/>
              <path d="M12 2v2M12 20v2M2 12h2M20 12h2" stroke="#222" stroke-width="2" stroke-linecap="round"/>
            </svg>
          `;
          btn.onclick = function() {
            if (navigator.geolocation) {
              navigator.geolocation.getCurrentPosition(function(pos) {
                map.flyTo({
                  center: [pos.coords.longitude, pos.coords.latitude],
                  zoom: 14
                });
              });
            } else {
              alert('Geolocation is not supported by your browser.');
            }
          };
          return btn;
        },
        onRemove: function() {
          document.getElementById('gps-btn')?.remove();
        }
      }),
      '' // empty string for custom position, so it overlays the map
    );
*/
    // Event listener for the clickable track menu
    const trackMenu = document.getElementById('track-menu');
    trackMenu.addEventListener('click', (e) => {
      const target = e.target;
      if (target.tagName === 'LI') {
        // Remove 'active' class from all list items
        document.querySelectorAll('.track-list li').forEach(li => li.classList.remove('active'));
        // Add 'active' class to the clicked item
        target.classList.add('active');

        const lat = parseFloat(target.dataset.lat);
        const lon = parseFloat(target.dataset.lon);

        // Fly the map to the new location with a smooth animation
        map.flyTo({
          center: [lon, lat],
          zoom: 12,
          speed: 1,
          curve: 1,
          easing(t) {
            return t;
          },
        });
      }
    });

    // --- Routing logic ---
    let startCoord = null;
    let targetCoord = null;
    const routeLayerId = 'valhalla-route';

    // Helper to update input fields
    function setCoordInput(id, coord) {
      document.getElementById(id).value = coord ? `${coord[1].toFixed(5)}, ${coord[0].toFixed(5)}` : '';
    }

    // Map click to set start/target
    let selectMode = 'start'; // 'start' or 'target'
    document.getElementById('start-coord').addEventListener('focus', () => selectMode = 'start');
    document.getElementById('target-coord').addEventListener('focus', () => selectMode = 'target');

    map.on('click', (e) => {
      const lngLat = [e.lngLat.lng, e.lngLat.lat];
      if (selectMode === 'start') {
        startCoord = lngLat;
        setCoordInput('start-coord', lngLat);
      } else {
        targetCoord = lngLat;
        setCoordInput('target-coord', lngLat);
      }
    });

    // Geocoder result to set start/target
    map.on('geocoder.result', (ev) => {
      const coord = ev.result.center;
      if (selectMode === 'start') {
        startCoord = coord;
        setCoordInput('start-coord', coord);
      } else {
        targetCoord = coord;
        setCoordInput('target-coord', coord);
      }
    });

    // Routing button
    document.getElementById('route-btn').onclick = async () => {
      if (!startCoord || !targetCoord) {
        alert('Please select both start and target points.');
        return;
      }
      const mode = document.getElementById('transport').value;

      // Build Valhalla route API request
      const url = 'https://valhalla1.openstreetmap.de/route';
      const body = {
        costing: mode,
        locations: [
          {lon: startCoord[0], lat: startCoord[1]},
          {lon: targetCoord[0], lat: targetCoord[1]}
        ],
        directions_options: {units: "kilometers"}
      };

      try {
        const resp = await fetch(url, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(body)
        });
        const data = await resp.json();
        console.log('Routing response:', data);
       
        if (data.trip) {
          // Decode the polyline and add it to the map
          const routeCoords = decodeValhallaPolyline(data.trip.legs[0].shape);
          if (map.getLayer(routeLayerId)) {
            map.removeLayer(routeLayerId);
            map.removeSource(routeLayerId);
          }
          map.addSource(routeLayerId, {
            type: 'geojson',
            data: {
              type: 'Feature',
              geometry: {
                type: 'LineString',
                coordinates: routeCoords
              }
            }
          });
          map.addLayer({
            id: routeLayerId,
            type: 'line',
            source: routeLayerId,
            paint: {
              'line-color': '#ff00cc',
              'line-width': 8,
              'line-opacity': 0.8
            }
          });

        const bbox = turf.bbox({
          type: 'Feature',
          geometry: {
            type: 'LineString',
            coordinates: routeCoords
          }
        });
        map.fitBounds(bbox, {padding: 40});




        } else {
          alert('No route found.');
        }

      } catch (err) {
        alert('Routing failed.');
        console.error(err);
      }
    };

    // Polyline decoder for Valhalla (Project-OSRM style)
    function decodeValhallaPolyline(str, precision) {
      var index = 0,
          lat = 0,
          lng = 0,
          coordinates = [],
          shift = 0,
          result = 0,
          byte = null,
          latitude_change,
          longitude_change,
          factor = Math.pow(10, precision || 6);

      while (index < str.length) {
        byte = null;
        shift = 0;
        result = 0;
        do {
          byte = str.charCodeAt(index++) - 63;
          result |= (byte & 0x1f) << shift;
          shift += 5;
        } while (byte >= 0x20);
        latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

        shift = result = 0;
        do {
          byte = str.charCodeAt(index++) - 63;
          result |= (byte & 0x1f) << shift;
          shift += 5;
        } while (byte >= 0x20);
        longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

        lat += latitude_change;
        lng += longitude_change;

        coordinates.push([lng / factor, lat / factor]);
      }
      return coordinates;
    }
    /*
    // Add turf.js for bbox calculation
    const turfScript = document.createElement('script');
    turfScript.src = 'https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js';
    document.head.appendChild(turfScript);
    */
    // Resize the Three.js canvas when the window is resized
    window.addEventListener('resize', () => {
      const width = carContainer.clientWidth;
      const height = carContainer.clientHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });
  </script>

</body>
</html>
